; NOTE
; We use three stacks:
;  - the builtin stack
;  - the operand stack
;  - the environment stack
;
; There is only one environment because we use dynamic scoping, for simplicity.
; 
; Here is a sketch of the memory map:
; 
; 0x0      ...   0x4FF		unusable in real mode
; 0x500    ...   0x7DFF		memory we can use for the stacks (including overwriting bootsector)
; 0x7e00   ...   0x7FFFF	second stage bootloader
;
; We divide the stack memory in three parts, each of length 0x2855
;   - [0x500,  0x2D54]
; 	- [0x2D55, 0x55A9]
;	- [0x55AA, 0x7DFF]

[org 0x7e00]
[bits 16]


%define CURRENT_RECORD ecx
%define OPERAND_POINTER edx
%define AR_AREA_POINTER esi

%define CURRENT_RECORD_BUF  0x500
%define OPERAND_POINTER_BUF 0x502
%define AR_AREA_POINTER_BUF  0x504

%macro 	push_operand 1
		mov edi, %1
		mov [OPERAND_POINTER], edi
		add OPERAND_POINTER, 2
%endmacro


%macro 	pop_operand 1
		sub OPERAND_POINTER, 2
		mov %1, [OPERAND_POINTER]
%endmacro

%macro 	make_record 0

		add AR_AREA_POINTER, 8
		mov [AR_AREA_POINTER + 6], word 0			; non-function check
		pop_operand ax								; argument
		mov [AR_AREA_POINTER + 4], ax				; save parameter
		pop_operand ax								; environment (definition record)
		mov [AR_AREA_POINTER + 2], ax				; save definition record
		mov eax, CURRENT_RECORD
		mov [AR_AREA_POINTER], ax					; save caller record
		
		pop_operand bx								; function
		
		
		mov CURRENT_RECORD, AR_AREA_POINTER
%endmacro

%macro 	make_HO_record 0
		add AR_AREA_POINTER, 8
		
		pop_operand ax								; par_def_record
		mov [AR_AREA_POINTER + 6], ax
		pop_operand ax								; argument
		mov [AR_AREA_POINTER + 4], ax				; save parameter
		pop_operand ax								; environment (definition record)
		mov [AR_AREA_POINTER + 2], ax				; save definition record
		
		mov eax, CURRENT_RECORD
		
		mov [AR_AREA_POINTER], ax					; save caller record
		
		pop_operand bx								; function
		
		mov CURRENT_RECORD, AR_AREA_POINTER
		
%endmacro

%macro print_cur_record 0
	pusha
	mov bx, REC_STRING
	call print_string
	popa
	
	pusha
	mov bx, [CURRENT_RECORD]
	call print_dec
	popa
	
	pusha
	mov bx, [CURRENT_RECORD + 2]
	call print_dec
	popa
	
	pusha
	mov bx, [CURRENT_RECORD + 4]
	call print_dec
	popa
	
	pusha
	mov bx, [CURRENT_RECORD + 6]
	call print_dec
	popa
	
	pusha
	mov bx, NEW_LINE
	call print_string
	popa
%endmacro


%macro 	say_here 0
	pusha
	mov bx, HERE_STRING
	pusha
	call print_string
	popa
	popa
%endmacro

%macro print_fun_pointer 1
	pusha
	mov bx, fun_%1
	call print_dec
	popa
%endmacro

%macro nl 0
	pusha
	mov bx, NEW_LINE
	call print_string
	popa
%endmacro

%macro call_debug_info 0
	pusha
	mov bx, FUN_STRING
	call print_string
	popa
	
	pusha
	mov bx, $
	sub bx, 9
	call print_dec
	popa
	
	pusha
	mov bx, NEW_LINE
	call print_string
	popa
	
	pusha
	mov bx, PAR_STRING
	call print_string
	popa
	
	mov ax, 0
	call printle
	mov ax, 1
	call printle
	mov ax, 2
	call printle
	
	pusha
	mov bx, NEW_LINE
	call print_string
	popa
%endmacro

%macro bufferize 0
	mov ax, word [CURRENT_RECORD]
	mov [CURRENT_RECORD_BUF], ax
	mov eax, OPERAND_POINTER
	mov [OPERAND_POINTER_BUF], ax
	mov eax, AR_AREA_POINTER
	mov [AR_AREA_POINTER_BUF], ax
%endmacro

%macro debufferize 0
	mov ax, [AR_AREA_POINTER_BUF]
	mov AR_AREA_POINTER, eax
	mov ax, [CURRENT_RECORD_BUF]
	mov CURRENT_RECORD, eax
	mov ax, [OPERAND_POINTER_BUF]
	mov OPERAND_POINTER, eax
%endmacro

	cli
	mov ax, 0x00
	mov ds, ax
	mov es, ax
	mov ss, ax
	mov sp, 0x2D55		; stack pointer
	sti

	; setup stacks, TODO rescale these (also have [0x500,  0x2D50])
	
	mov AR_AREA_POINTER, 0x2D55
	mov OPERAND_POINTER, 0x55AA
	mov CURRENT_RECORD, AR_AREA_POINTER

mov bx, STAGING
call print_string

; push_env print_number

; GENERATED CODE WILL BE WRITTEN HERE


;print_fun_pointer 1
;print_fun_pointer 2
;print_fun_pointer 3
;print_fun_pointer 4
;print_fun_pointer 5
;print_fun_pointer 6
;print_fun_pointer 7
nl
